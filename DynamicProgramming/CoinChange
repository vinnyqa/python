# There is an m x n grid where you are allowed to move either down or to the right at any point in time.
# Given the two integers m and n, return the number of possible unique paths that can be taken from the top-left corner of the grid (grid[0][0]) to the bottom-right corner (grid[m - 1][n - 1]).
# You may assume the output will fit in a 32-bit integer.

class Solution:
    def coinChange(self, coins: list[int], amount: int) -> int:
        dp = [amount+1] * (amount+1) #We are going from 0 to amount+1
        dp[0] = 0

        for a in range(1,amount+1): #Bottom Up
            for c in coins:
                if a - c >= 0:
                    dp[a] = min(dp[a], 1 + dp[a-c]) #Recurrence Relation
                    
        return dp[amount] if dp[amount] != (amount+1) else -1
        #If it's not the default value we initialized (amount+1)

sol = Solution()
coins=[1,2,5]
amount=11
output = 3
print(sol.coinChange(coins,amount))
# Time : O(2^m+n), Space : O(m+n)
# RECURSION HASHSET